"""
sync_hugo.py — Generate Hugo markdown content files from YAML data.

Generates:
  - site/content/publications/<id>/index.md  (one per publication)
  - site/content/media/_index.md             (commentary & media page)
  - site/content/code/_index.md              (software/code page)

Uses .generated marker files for safe cleanup of generated directories.
Hand-created directories without the marker are preserved.
"""

import sys
import shutil
from datetime import datetime
from pathlib import Path

# Add parent to path so we can import utils
sys.path.insert(0, str(Path(__file__).resolve().parent))

from utils import (
    load_all_data,
    validate_data,
    filter_pubs_by_theme,
    format_authors,
    CONTENT_DIR,
    STATIC_DIR,
    CV_OUTPUT_DIR,
)


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

PUBLICATIONS_DIR = CONTENT_DIR / "publications"
MEDIA_DIR = CONTENT_DIR / "media"
CODE_DIR = CONTENT_DIR / "code"
GENERATED_MARKER = ".generated"


# ---------------------------------------------------------------------------
# Safe cleanup with .generated markers
# ---------------------------------------------------------------------------

def clean_generated_dirs(parent_dir: Path):
    """
    Delete only subdirectories under parent_dir that contain a .generated
    marker file. Hand-created directories without the marker are preserved.
    """
    if not parent_dir.exists():
        return
    for child in parent_dir.iterdir():
        if child.is_dir() and (child / GENERATED_MARKER).exists():
            shutil.rmtree(child)


def write_generated_marker(directory: Path, source_id: str):
    """
    Write a .generated marker file into a directory.
    Contains a timestamp and the source YAML entry id.
    """
    marker = directory / GENERATED_MARKER
    marker.write_text(
        f"Generated by sync_hugo.py\n"
        f"Source ID: {source_id}\n"
        f"Timestamp: {datetime.now().isoformat()}\n"
    )


# ---------------------------------------------------------------------------
# Publication page generation
# ---------------------------------------------------------------------------

def _pub_type_label(pub_type: str) -> str:
    """Map internal type to display label."""
    labels = {
        "journal": "Journal Article",
        "working_paper": "Working Paper",
        "report": "Report",
        "book_chapter": "Book Chapter",
        "commentary": "Commentary",
        "policy_brief": "Policy Brief",
    }
    return labels.get(pub_type, pub_type.replace("_", " ").title())


def _yaml_escape(text: str) -> str:
    """Escape a string for safe inclusion in YAML frontmatter double quotes."""
    if not text:
        return ""
    return text.replace("\\", "\\\\").replace('"', '\\"')


def generate_publication_page(pub: dict) -> str:
    """Generate Hugo markdown content for a single publication."""
    pub_id = pub["id"]
    title = pub["title"]
    year = pub.get("year", "")
    authors = pub.get("authors", [])
    pub_type = pub.get("type", "journal")
    journal = pub.get("journal", "")
    volume = pub.get("volume", "")
    issue = pub.get("issue", "")
    pages = pub.get("pages", "")
    doi = pub.get("doi", "")
    status = pub.get("status", "")
    featured = pub.get("featured", False)
    media = pub.get("media", [])
    awards = pub.get("awards", [])
    book = pub.get("book", "")
    editors = pub.get("editors", "")
    publisher = pub.get("publisher", "")
    series = pub.get("series", "")
    summary = pub.get("summary", "")
    links = pub.get("links", [])

    # Build frontmatter
    lines = [
        "---",
        f'title: "{_yaml_escape(title)}"',
        f"date: {year}-01-01",
    ]

    # Authors as YAML list
    lines.append("authors:")
    for author in authors:
        lines.append(f'  - "{_yaml_escape(author)}"')

    lines.append(f'publication_type: "{_yaml_escape(_pub_type_label(pub_type))}"')

    # Publication venue
    if journal:
        venue = f"*{journal}*"
        if volume:
            venue += f", {volume}"
        if issue:
            venue += f"({issue})"
        if pages:
            venue += f", {pages}"
        lines.append(f'publication: "{_yaml_escape(venue)}"')
    elif book:
        venue = f"In *{book}*"
        if editors:
            venue = f"In {editors} (Eds.), *{book}*"
        if publisher:
            venue += f". {publisher}"
        lines.append(f'publication: "{_yaml_escape(venue)}"')
    elif publisher:
        lines.append(f'publication: "{_yaml_escape(publisher)}"')
    elif series:
        lines.append(f'publication: "{_yaml_escape(series)}"')

    if status:
        lines.append(f'publication_short: "{_yaml_escape(status)}"')

    if doi:
        lines.append(f'doi: "{doi}"')

    if featured:
        lines.append("featured: true")

    # New optional fields for card layout (website-only)
    if summary:
        lines.append(f'summary: "{_yaml_escape(summary)}"')

    image = pub.get("image", "")
    if image:
        lines.append(f'image: "{_yaml_escape(image)}"')

    if links:
        lines.append("links:")
        for link in links:
            lines.append(f'  - label: "{_yaml_escape(link.get("label", ""))}"')
            lines.append(f'    url: "{_yaml_escape(link.get("url", ""))}"')

    lines.append("---")
    lines.append("")

    # Body content
    if awards:
        for award in awards:
            lines.append(f"**{award}**")
        lines.append("")

    if media:
        lines.append("**Selected Media Coverage:** " + ", ".join(media))
        lines.append("")

    return "\n".join(lines)


def generate_publications(pubs: list):
    """Generate all publication pages under site/content/publications/."""
    PUBLICATIONS_DIR.mkdir(parents=True, exist_ok=True)

    # Clean previously generated directories
    clean_generated_dirs(PUBLICATIONS_DIR)

    for pub in pubs:
        pub_id = pub["id"]
        pub_dir = PUBLICATIONS_DIR / pub_id
        pub_dir.mkdir(parents=True, exist_ok=True)

        # Write the content file
        content = generate_publication_page(pub)
        (pub_dir / "index.md").write_text(content, encoding="utf-8")

        # Write the .generated marker
        write_generated_marker(pub_dir, pub_id)

    print(f"  Generated {len(pubs)} publication pages in {PUBLICATIONS_DIR}")



def _html_escape(text: str) -> str:
    """Escape HTML special characters in text."""
    if not text:
        return ""
    return (
        text.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
    )


def _format_citation_html(pub: dict) -> str:
    """
    Format a publication as an APA-style citation with HTML markup.
    Journal/book names are wrapped in <em> tags instead of markdown *italics*.
    """
    parts = []

    # Authors
    authors = pub.get("authors", [])
    if authors:
        parts.append(_html_escape(format_authors(authors)))

    # Year
    year = pub.get("year", "")
    if year:
        parts.append(f"({year}).")

    # Title
    title = pub.get("title", "")
    if title:
        parts.append(f"{_html_escape(title)}.")

    # Journal / book / publisher
    journal = pub.get("journal", "")
    book = pub.get("book", "")
    publisher = pub.get("publisher", "")

    if journal:
        vol = pub.get("volume", "")
        issue = pub.get("issue", "")
        pages = pub.get("pages", "")
        article_number = pub.get("article_number", "")
        journal_str = f"<em>{_html_escape(journal)}</em>"
        if vol:
            journal_str += f", {_html_escape(vol)}"
        if issue:
            journal_str += f"({_html_escape(issue)})"
        if pages:
            journal_str += f", {_html_escape(pages)}"
        elif article_number:
            journal_str += f", {_html_escape(article_number)}"
        parts.append(journal_str + ".")
    elif book:
        editors = pub.get("editors", "")
        if editors:
            parts.append(f"In {_html_escape(editors)} (Eds.),")
        parts.append(f"<em>{_html_escape(book)}</em>.")
        if publisher:
            parts.append(f"{_html_escape(publisher)}.")
    elif publisher:
        parts.append(f"{_html_escape(publisher)}.")

    return " ".join(parts)


def _generate_pub_card_html(pub: dict) -> str:
    """Generate the HTML for a single publication card."""
    pub_id = pub["id"]
    title = pub.get("title", "")
    pub_type = pub.get("type", "journal")
    summary = pub.get("summary", "")
    image = pub.get("image", "")
    doi = pub.get("doi", "")
    status = pub.get("status", "")
    awards = pub.get("awards", [])
    links = pub.get("links") or []

    # Build the citation in HTML
    citation_html = _format_citation_html(pub)

    # Build link buttons
    link_buttons = []

    # Add explicit links from YAML
    for link in links:
        label = _html_escape(link.get("label", ""))
        url = _html_escape(link.get("url", ""))
        link_buttons.append(
            f'<a href="{url}" class="pub-card-link" target="_blank" rel="noopener">{label}</a>'
        )

    # Add DOI button if DOI exists and wasn't already in links
    has_doi_link = any(l.get("label", "").lower() == "doi" for l in links)
    if doi and not has_doi_link:
        link_buttons.append(
            f'<a href="https://doi.org/{_html_escape(doi)}" class="pub-card-link" target="_blank" rel="noopener">DOI</a>'
        )

    # Build citation parts
    citation_parts = [citation_html]
    if status:
        citation_parts.append(f'<span class="pub-card-status">{_html_escape(status)}</span>')
    if awards:
        for award in awards:
            citation_parts.append(f'<span class="pub-card-award">{_html_escape(award)}</span>')

    # Build the card HTML
    card_lines = []

    # If image exists, wrap card + image in a side-by-side row
    if image:
        card_lines.append(f'<div class="pub-card-wrapper">')

    card_lines.append(f'<div class="pub-card">')
    type_label = _pub_type_label(pub_type)
    card_lines.append(f'  <span class="pub-card-type-badge">{_html_escape(type_label)}</span>')
    card_lines.append(f'  <h3 class="pub-card-title">{_html_escape(title)}</h3>')

    if summary:
        card_lines.append(f'  <p class="pub-card-summary">{_html_escape(summary)}</p>')

    card_lines.append(f'  <div class="pub-card-citation">')
    card_lines.append(f'    {" ".join(citation_parts)}')
    card_lines.append(f'  </div>')

    if link_buttons:
        card_lines.append(f'  <div class="pub-card-links">')
        card_lines.append(f'    {" ".join(link_buttons)}')
        card_lines.append(f'  </div>')

    card_lines.append(f'</div>')

    # Article image alongside the card (only if image field is provided)
    if image:
        card_lines.append(f'<div class="pub-card-image">')
        card_lines.append(f'  <img src="/images/publications/{_html_escape(image)}" alt="{_html_escape(title)}" />')
        card_lines.append(f'</div>')
        card_lines.append(f'</div>')

    return "\n".join(card_lines)


def generate_publications_index(pubs: list, theme_order: list):
    """
    Generate the publications section _index.md with HTML card layout.

    Organized by research theme with collapsible <details>/<summary> sections
    for journal articles and working papers. Reports, book chapters, and
    commentaries appear in a flat "Other Publications" section at the bottom.
    """
    lines = [
        "---",
        'title: "Publications"',
        "cascade:",
        "  build:",
        "    list: never",
        "---",
        "",
    ]

    # --- Collapsible theme sections for journals + working papers ---
    for theme in theme_order:
        theme_key = theme["key"]
        theme_name = theme["name"]
        theme_pubs = filter_pubs_by_theme(pubs, theme_key)
        if not theme_pubs:
            continue

        # Sort by year descending
        theme_pubs.sort(key=lambda p: p.get("year", 0), reverse=True)
        count = len(theme_pubs)

        lines.append(f'<details class="pub-theme-section">')
        lines.append(f'<summary class="pub-theme-header">')
        lines.append(f'  <span class="pub-theme-name">{_html_escape(theme_name)}</span>')
        lines.append(
            f'  <span class="pub-theme-count">'
            f'({count} publication{"s" if count != 1 else ""})'
            f'</span>'
        )
        lines.append(f'</summary>')
        lines.append(f'<div class="pub-theme-content">')
        lines.append(f'<div class="pub-card-list">')
        lines.append("")

        for pub in theme_pubs:
            lines.append(_generate_pub_card_html(pub))
            lines.append("")

        lines.append("</div>")
        lines.append("</div>")
        lines.append("</details>")
        lines.append("")

    content = "\n".join(lines)
    (PUBLICATIONS_DIR / "_index.md").write_text(content, encoding="utf-8")
    print(f"  Generated publications index page (themed card layout)")


# ---------------------------------------------------------------------------
# Media page generation
# ---------------------------------------------------------------------------

def generate_media_page(media_data: dict):
    """Generate the Commentary & Media page at site/content/media/_index.md."""
    MEDIA_DIR.mkdir(parents=True, exist_ok=True)

    commentary = media_data.get("commentary", [])
    news_coverage = media_data.get("news_coverage", [])
    podcasts = media_data.get("podcasts_interviews", [])

    lines = [
        "---",
        'title: "Commentary & Media"',
        "---",
        "",
    ]

    # Commentary & Op-Eds
    if commentary:
        lines.append("## Commentary & Op-Eds")
        lines.append("")
        # Sort by date descending
        commentary_sorted = sorted(
            commentary, key=lambda x: x.get("date", ""), reverse=True
        )
        for item in commentary_sorted:
            title = item.get("title", "")
            authors = item.get("authors", [])
            date = item.get("date", "")
            outlet = item.get("outlet", "")
            url = item.get("url", "")

            author_str = format_authors(authors) if authors else ""
            # Format date nicely
            date_str = ""
            if date:
                try:
                    d = datetime.strptime(date, "%Y-%m-%d")
                    date_str = d.strftime("%B %d, %Y")
                except ValueError:
                    date_str = date

            entry = f"- {author_str}"
            if date_str:
                entry += f" ({date_str})."
            if url:
                entry += f' "[{title}]({url})."'
            else:
                entry += f' "{title}."'
            if outlet:
                entry += f" *{outlet}*."

            lines.append(entry)
            lines.append("")

    # News Coverage
    if news_coverage:
        lines.append("## Selected News Coverage")
        lines.append("")
        for item in news_coverage:
            pub_id = item.get("publication_id", "")
            outlets = item.get("outlets", [])
            if outlets:
                outlet_names = [o.get("name", "") for o in outlets]
                lines.append(f"- **{pub_id}**: {', '.join(outlet_names)}")
                lines.append("")

    # Podcasts & Interviews
    if podcasts:
        lines.append("## Podcasts & Interviews")
        lines.append("")
        for item in podcasts:
            title = item.get("title", "")
            outlet = item.get("outlet", "")
            date = item.get("date", "")
            url = item.get("url", "")

            if url:
                lines.append(f"- [{title}]({url}) — *{outlet}* ({date})")
            else:
                lines.append(f"- {title} — *{outlet}* ({date})")
            lines.append("")

    content = "\n".join(lines)
    (MEDIA_DIR / "_index.md").write_text(content, encoding="utf-8")
    print(f"  Generated media page")


# ---------------------------------------------------------------------------
# Code/Software page generation
# ---------------------------------------------------------------------------

def generate_code_page(software_data: dict):
    """Generate the Code page at site/content/code/_index.md."""
    CODE_DIR.mkdir(parents=True, exist_ok=True)

    software = software_data.get("software", [])

    lines = [
        "---",
        'title: "Code"',
        "---",
        "",
        "## Software Packages",
        "",
    ]

    for pkg in software:
        name = pkg.get("name", "")
        desc = pkg.get("description", "").strip()
        languages = pkg.get("languages", [])
        github = pkg.get("github", "")
        r_name = pkg.get("r_package_name", "")
        reference = pkg.get("reference", "")

        lines.append(f"### {name}")
        lines.append("")
        lines.append(desc)
        lines.append("")

        if languages:
            lines.append(f"**Languages:** {', '.join(languages)}")
            if r_name:
                lines[-1] += f" (R package name: `{r_name}`)"
            lines.append("")

        if github:
            lines.append(f"**GitHub:** [{github}]({github})")
            lines.append("")

        if reference:
            lines.append(f"**Reference:** {reference}")
            lines.append("")

    content = "\n".join(lines)
    (CODE_DIR / "_index.md").write_text(content, encoding="utf-8")
    print(f"  Generated code page")


# ---------------------------------------------------------------------------
# Copy CV PDF to static directory
# ---------------------------------------------------------------------------

def copy_cv_pdf():
    """Copy the generated CV PDF to site/static/uploads/ for download."""
    pdf_src = CV_OUTPUT_DIR / "McEachin_CV.pdf"
    if pdf_src.exists():
        dest = STATIC_DIR / "uploads" / "McEachin_CV.pdf"
        dest.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(pdf_src, dest)
        print(f"  Copied CV PDF to {dest}")
    else:
        print(f"  WARNING: CV PDF not found at {pdf_src}, skipping copy", file=sys.stderr)


# ---------------------------------------------------------------------------
# Main entry point
# ---------------------------------------------------------------------------

def main(data: dict = None):
    """
    Main entry point. Accepts pre-loaded data dict, or loads from YAML.
    When data is pre-provided (from build_all.py), validation is skipped
    since the orchestrator already validated.
    """
    if data is None:
        data = load_all_data()
        # Only validate when loading our own data
        errors = validate_data(data)
        if errors:
            print("Validation errors:", file=sys.stderr)
            for err in errors:
                print(f"  - {err}", file=sys.stderr)
            sys.exit(1)

    print("Syncing Hugo content from YAML data...")

    # Publications
    pubs_data = data.get("publications", {})
    pubs = pubs_data.get("publications", [])
    theme_order = pubs_data.get("theme_order", [])
    generate_publications(pubs)
    generate_publications_index(pubs, theme_order)

    # Media
    generate_media_page(data.get("media", {}))

    # Code/Software
    generate_code_page(data.get("software", {}))

    # Copy CV PDF if it exists
    copy_cv_pdf()

    print("Done syncing Hugo content.")


if __name__ == "__main__":
    main()
